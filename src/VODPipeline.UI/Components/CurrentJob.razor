@using VODPipeline.UI.Data
@using VODPipeline.UI.Services
@using VODPipeline.UI.Utilities
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Extensions.Logging
@implements IAsyncDisposable
@inject ILogger<CurrentJob> Logger
@inject JobService JobService

<div class="current-job">
    @if (DisplayStatus?.IsRunning == true)
    {
        <h4>Current Job</h4>
        <div class="job-details">
            <div class="job-field">
                <strong>File:</strong> @DisplayStatus.CurrentFile
            </div>
            <div class="job-field">
                <strong>Stage:</strong> @DisplayStatus.Stage
            </div>
            <div class="job-field">
                <strong>Progress:</strong> @(DisplayStatus.Percent ?? 0)%
            </div>
            @if (EstimatedTimeRemaining.HasValue)
            {
                <div class="job-field">
                    <strong>ETA:</strong> @FormatHelper.FormatDuration(EstimatedTimeRemaining.Value)
                </div>
            }
            @if (EstimatedCompletionTime.HasValue)
            {
                <div class="job-field">
                    <strong>Est. Completion:</strong> @EstimatedCompletionTime.Value.ToLocalTime().ToString("HH:mm")
                </div>
            }
            @if (DisplayStatus.ElapsedTime.HasValue)
            {
                <div class="job-field">
                    <strong>Elapsed:</strong> @FormatHelper.FormatDuration(DisplayStatus.ElapsedTime.Value)
                </div>
            }
            @if (DisplayStatus.LastUpdated.HasValue)
            {
                <div class="job-field text-muted">
                    <small>Last Updated: @DisplayStatus.LastUpdated.Value.ToLocalTime().ToString("HH:mm:ss zzz")</small>
                </div>
            }
        </div>
    }
    else
    {
        <div class="no-job">
            <p>No active job running</p>
        </div>
    }
    @if (signalRConnectionFailed)
    {
        <div class="connection-warning">
            <small>⚠️ Live updates unavailable - displaying cached status</small>
        </div>
    }
</div>

@code {
    [Parameter]
    public JobStatus? InitialJobStatus { get; set; }

    [Parameter]
    public string? HubUrl { get; set; }

    private JobStatus? CurrentJobStatus { get; set; }
    private TimeSpan? EstimatedTimeRemaining { get; set; }
    private DateTime? EstimatedCompletionTime { get; set; }

    private HubConnection? hubConnection;
    private bool signalRConnectionFailed = false;
    private string? previousHubUrl;

    // Property for backward compatibility and to simplify the UI logic
    private JobStatus? DisplayStatus => CurrentJobStatus ?? InitialJobStatus;

    protected override async Task OnInitializedAsync()
    {
        // Fetch initial job state from API if not provided via parameter
        if (InitialJobStatus == null)
        {
            try
            {
                InitialJobStatus = await JobService.GetStatusAsync();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Failed to fetch initial job status from API.");
            }
        }

        if (!string.IsNullOrEmpty(HubUrl))
        {
            await InitializeSignalRConnection();
            previousHubUrl = HubUrl;
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // Handle HubUrl changes
        // Note: InitialJobStatus parameter updates from parent will be overridden by SignalR events
        // when the connection is active, as SignalR provides the authoritative real-time state.
        if (HubUrl != previousHubUrl)
        {
            if (hubConnection is not null)
            {
                await CleanupSignalRConnection();
            }

            if (!string.IsNullOrEmpty(HubUrl))
            {
                await InitializeSignalRConnection();
            }
            
            previousHubUrl = HubUrl;
        }
    }

    private async Task InitializeSignalRConnection()
    {
        try
        {
            signalRConnectionFailed = false;
            
            hubConnection = new HubConnectionBuilder()
                .WithUrl(HubUrl!)
                .WithAutomaticReconnect()
                .Build();

            // Handle reconnection events
            hubConnection.Reconnecting += async (error) =>
            {
                await InvokeAsync(() =>
                {
                    signalRConnectionFailed = true;
                });
            };

            hubConnection.Reconnected += async (connectionId) =>
            {
                await InvokeAsync(() =>
                {
                    signalRConnectionFailed = false;
                });
            };

            hubConnection.Closed += async (error) =>
            {
                await InvokeAsync(() =>
                {
                    signalRConnectionFailed = true;
                });
            };

            // Subscribe to job lifecycle events
            hubConnection.On<JobStatus>("jobStarted", async (updatedStatus) =>
            {
                await HandleJobStatusUpdate(updatedStatus, "jobStarted");
            });

            hubConnection.On<JobStatus>("jobProgressUpdated", async (updatedStatus) =>
            {
                await HandleJobStatusUpdate(updatedStatus, "jobProgressUpdated");
            });

            hubConnection.On<JobStatus>("jobStateChanged", async (updatedStatus) =>
            {
                await HandleJobStatusUpdate(updatedStatus, "jobStateChanged");
            });

            hubConnection.On<JobStatus>("jobCompleted", async (updatedStatus) =>
            {
                await HandleJobStatusUpdate(updatedStatus, "jobCompleted");
            });

            await hubConnection.StartAsync();
        }
        catch (Exception ex)
        {
            signalRConnectionFailed = true;
            Logger.LogError(ex, "Failed to establish SignalR connection to hub at {HubUrl}", HubUrl);
            
            // Cleanup partially initialized connection
            try
            {
                if (hubConnection is not null)
                {
                    await hubConnection.DisposeAsync();
                }
            }
            catch (Exception disposeEx)
            {
                Logger.LogError(disposeEx, "Error disposing SignalR hub connection after failed start.");
            }
            finally
            {
                hubConnection = null;
            }
        }
    }

    private async Task CleanupSignalRConnection()
    {
        var connection = hubConnection;
        if (connection is not null)
        {
            hubConnection = null; // Clear reference first to prevent reuse
            
            try
            {
                await connection.StopAsync();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error while stopping SignalR hub connection.");
            }

            try
            {
                await connection.DisposeAsync();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error while disposing SignalR hub connection.");
            }
        }
    }

    private async Task HandleJobStatusUpdate(JobStatus? updatedStatus, string eventName)
    {
        try
        {
            await InvokeAsync(() =>
            {
                if (updatedStatus == null)
                {
                    CurrentJobStatus = null;
                    EstimatedTimeRemaining = null;
                    EstimatedCompletionTime = null;
                    StateHasChanged();
                    return;
                }

                // Check if this is a new job (different JobID or FileName)
                bool isNewJob = IsNewJob(updatedStatus);
                
                if (isNewJob)
                {
                    // New job detected - update InitialJobStatus and clear CurrentJobStatus
                    InitialJobStatus = updatedStatus;
                    CurrentJobStatus = null;
                    EstimatedTimeRemaining = null;
                    EstimatedCompletionTime = null;
                }
                else
                {
                    // Update CurrentJobStatus
                    CurrentJobStatus = updatedStatus;
                    
                    // Calculate estimated time remaining and completion time
                    UpdateEstimates();
                }
                
                StateHasChanged();
            });
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error handling {EventName} SignalR event.", eventName);
        }
    }

    private bool IsNewJob(JobStatus updatedStatus)
    {
        // If we don't have an initial status yet, this is the first job
        if (InitialJobStatus == null)
        {
            return true;
        }

        // Check if JobID has changed (indicating a new job)
        if (!string.IsNullOrEmpty(updatedStatus.JobID) && 
            updatedStatus.JobID != InitialJobStatus.JobID)
        {
            return true;
        }

        // Check if FileName has changed (indicating a new job)
        if (!string.IsNullOrEmpty(updatedStatus.FileName) && 
            updatedStatus.FileName != InitialJobStatus.FileName)
        {
            return true;
        }

        return false;
    }

    private void UpdateEstimates()
    {
        // We need both InitialJobStatus and CurrentJobStatus with TimeStamp to calculate
        if (InitialJobStatus?.TimeStamp == null || CurrentJobStatus?.TimeStamp == null)
        {
            EstimatedTimeRemaining = null;
            EstimatedCompletionTime = null;
            return;
        }

        // Calculate elapsed time
        TimeSpan elapsedTime = CurrentJobStatus.TimeStamp.Value - InitialJobStatus.TimeStamp.Value;
        
        // Get current percent complete
        int currentPercent = CurrentJobStatus.Percent ?? 0;
        
        // Can't calculate if no progress has been made
        if (currentPercent <= 0 || elapsedTime.TotalSeconds <= 0)
        {
            EstimatedTimeRemaining = null;
            EstimatedCompletionTime = null;
            return;
        }

        // Calculate remaining percent
        int remainingPercent = 100 - currentPercent;
        
        // Calculate estimated time remaining
        // Formula: elapsed * (remaining / completed)
        double estimatedRemainingSeconds = elapsedTime.TotalSeconds * ((double)remainingPercent / currentPercent);
        EstimatedTimeRemaining = TimeSpan.FromSeconds(estimatedRemainingSeconds);
        
        // Calculate estimated completion time (current time + estimated remaining)
        EstimatedCompletionTime = DateTime.UtcNow.Add(EstimatedTimeRemaining.Value);
    }

    private string FormatTimeSpan(TimeSpan timeSpan)
    {
        if (timeSpan < TimeSpan.Zero)
        {
            return "N/A";
        }
        
        if (timeSpan.TotalHours >= 1)
        {
            return $"{(int)timeSpan.TotalHours}h {timeSpan.Minutes}m {timeSpan.Seconds}s";
        }
        else if (timeSpan.TotalMinutes >= 1)
        {
            return $"{timeSpan.Minutes}m {timeSpan.Seconds}s";
        }
        else if (timeSpan.TotalSeconds >= 1)
        {
            return $"{(int)timeSpan.TotalSeconds}s";
        }
        else if (timeSpan.TotalMilliseconds >= 1)
        {
            return $"{(int)timeSpan.TotalMilliseconds}ms";
        }
        else
        {
            return "<1ms";
        }
    }

    public async ValueTask DisposeAsync()
    {
        await CleanupSignalRConnection();
    }
}
